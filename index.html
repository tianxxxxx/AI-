<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>双手实体动态交互系统 Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Roboto', sans-serif; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #1b1b2f, #000000);}
        #input-video { display: none; }
        
        /* 侧边栏 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 340px; max-height: 90vh;
            background: rgba(20, 23, 35, 0.95); padding: 25px; border-radius: 16px;
            border: 1px solid rgba(0, 255, 170, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.1);
            z-index: 100; overflow-y: auto;
        }

        h2 { margin: 0 0 15px 0; font-family: 'Orbitron', sans-serif; color: #00ffaa; letter-spacing: 2px; border-bottom: 1px solid rgba(0,255,170,0.2); padding-bottom: 10px;}
        
        .status-bar { margin-bottom: 15px; font-size: 12px; color: #888; display: flex; justify-content: space-between;}
        
        input { 
            width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid #334; 
            border-radius: 6px; background: #0f1220; color: #fff; outline: none; transition: border 0.3s;
        }
        input:focus { border-color: #00ffaa; }

        /* 录制按钮 - 切换状态 */
        #record-btn {
            width: 100%; padding: 15px; border: none; border-radius: 6px;
            background: linear-gradient(90deg, #00c6ff, #0072ff); color: white; 
            font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.3s; font-family: 'Orbitron', sans-serif;
        }
        #record-btn.recording {
            background: linear-gradient(90deg, #ff4444, #cc0000);
            animation: pulse-red 1s infinite;
        }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); } }

        /* 倒计时遮罩 */
        #countdown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center;
            z-index: 200;
        }
        #countdown-text {
            font-family: 'Orbitron', sans-serif; font-size: 150px; font-weight: 900;
            color: #00ffaa; text-shadow: 0 0 50px #00ffaa;
            animation: scale-up 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) infinite;
        }
        @keyframes scale-up { 0% { transform: scale(0.5); opacity: 0; } 50% { opacity: 1; } 100% { transform: scale(1.2); opacity: 0; } }

        .list-wrap { margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }
        .gesture-item { 
            background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 4px; 
            display: flex; justify-content: space-between; align-items: center; font-size: 13px;
        }
        .del-btn { color: #ff5555; cursor: pointer; padding: 5px; font-weight: bold;}

        /* 相似度条 */
        .match-info { margin-top: 15px; font-size: 12px; color: #aaa; }
        .bar-bg { width: 100%; height: 6px; background: #333; margin-top: 5px; border-radius: 3px; overflow: hidden;}
        .bar-fill { height: 100%; width: 0%; background: #00ffaa; transition: width 0.1s; }

        /* 屏幕中央显示 */
        #main-output {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-size: 80px; font-weight: 900; 
            color: #fff; text-shadow: 0 0 30px rgba(0, 255, 170, 0.8);
            opacity: 0; transition: all 0.3s; pointer-events: none; z-index: 50; text-align: center; white-space: nowrap;
        }
        #main-output.active { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="countdown-overlay">
        <div id="countdown-text">3</div>
    </div>
    
    <div id="ui-layer">
        <h2>Dual-Core System</h2>
        <div class="status-bar">
            <span>状态: <span id="status-text" style="color:#00ffaa">就绪</span></span>
            <span>Hands: <span id="hand-count">0</span></span>
        </div>
        
        <input type="text" id="gesture-name" placeholder="输入动作名称 (如: 结印)">
        
        <div style="font-size:11px; color:#aaa; margin-bottom:8px;">点击录制 -> 3秒倒计时 -> 做出动作 -> 再次点击停止</div>
        <button id="record-btn" onclick="toggleRecording()">开始录制 (倒计时)</button>

        <div class="match-info">
            相似度匹配: <span id="score-val">0</span>
            <div class="bar-bg"><div class="bar-fill" id="score-bar"></div></div>
        </div>

        <div class="list-wrap" id="gesture-list"></div>

        <button onclick="exportData()" style="background:#333; margin-top:20px; font-size:12px; border:1px solid #555;">导出JSON数据</button>
    </div>

    <div id="main-output">SYSTEM READY</div>
</div>

<script>
    // ============================================
    // 1. Three.js 实体化机械手 (支持双手)
    // ============================================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 20); 

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.getElementById('container').appendChild(renderer.domElement);

    // 灯光
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);
    const pointLight = new THREE.PointLight(0x00ffaa, 1, 30);
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // 材质
    const jointMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.9 });
    const boneMatLeft = new THREE.MeshStandardMaterial({ color: 0x00ffaa, roughness: 0.2, metalness: 0.5, emissive: 0x004433, emissiveIntensity: 0.4 });
    const boneMatRight = new THREE.MeshStandardMaterial({ color: 0xff0055, roughness: 0.2, metalness: 0.5, emissive: 0x440011, emissiveIntensity: 0.4 });

    const BONE_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17],[0,5]];

    class SolidHand {
        constructor(isRight) {
            this.group = new THREE.Group();
            scene.add(this.group);
            this.joints = [];
            this.bones = [];
            
            const boneMat = isRight ? boneMatRight : boneMatLeft;

            const sphereGeo = new THREE.SphereGeometry(0.45, 16, 16);
            for(let i=0; i<21; i++) {
                const mesh = new THREE.Mesh(sphereGeo, jointMat);
                mesh.castShadow = true;
                this.joints.push(mesh);
                this.group.add(mesh);
            }

            const cylinderGeo = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
            cylinderGeo.translate(0, 0.5, 0); 
            cylinderGeo.rotateX(Math.PI / 2);
            
            BONE_CONNECTIONS.forEach(pair => {
                const bone = new THREE.Mesh(cylinderGeo, boneMat);
                bone.castShadow = true;
                this.bones.push({ mesh: bone, start: pair[0], end: pair[1] });
                this.group.add(bone);
            });
        }

        update(landmarks) {
            if (!landmarks) { this.group.visible = false; return; }
            this.group.visible = true;
            const worldPositions = [];
            landmarks.forEach((lm, i) => {
                const x = (0.5 - lm.x) * 32;
                const y = (0.5 - lm.y) * 26;
                const z = lm.z * -30;
                this.joints[i].position.set(x, y, z);
                worldPositions.push(new THREE.Vector3(x, y, z));
            });
            this.bones.forEach(b => {
                const startPos = worldPositions[b.start];
                const endPos = worldPositions[b.end];
                b.mesh.position.copy(startPos);
                b.mesh.lookAt(endPos);
                const distance = startPos.distanceTo(endPos);
                b.mesh.scale.set(1, 1, distance);
            });
        }
    }

    // 两个实体手实例
    const leftHandVisual = new SolidHand(false); // 蓝绿色
    const rightHandVisual = new SolidHand(true); // 红色


    // ============================================
    // 2. 双手 DTW 核心逻辑
    // ============================================

    let isRecording = false;
    let recordedBuffer = []; 
    const LIVE_BUFFER_SIZE = 45; // 历史窗口大小
    let liveBuffer = []; 
    let gestureDB = []; 

    // 初始化加载
    const savedData = localStorage.getItem('dualHandGestures');
    if(savedData) { gestureDB = JSON.parse(savedData); renderList(); }

    // 特征提取：核心变更
    // 返回一个长向量 [Left_Feats(15), Right_Feats(15)]
    // 如果某只手不存在，用0填充
    function extractDualFeatures(leftLM, rightLM) {
        let feats = [];
        
        const processHand = (landmarks) => {
            if(!landmarks) return Array(15).fill(0);
            const wrist = landmarks[0];
            let scale = 0;
            // 计算尺度用于归一化
            landmarks.forEach(p => {
                const d = Math.sqrt((p.x-wrist.x)**2 + (p.y-wrist.y)**2 + (p.z-wrist.z)**2);
                if(d > scale) scale = d;
            });
            if (scale === 0) scale = 1;
            
            const handFeats = [];
            // 取5个指尖相对于手腕的位置
            [4, 8, 12, 16, 20].forEach(idx => {
                handFeats.push((landmarks[idx].x - wrist.x) / scale);
                handFeats.push((landmarks[idx].y - wrist.y) / scale);
                handFeats.push((landmarks[idx].z - wrist.z) / scale);
            });
            return handFeats;
        };

        // 拼接：先左后右
        feats = feats.concat(processHand(leftLM));
        feats = feats.concat(processHand(rightLM));
        return feats;
    }

    function computeDTW(seq1, seq2) {
        const n = seq1.length;
        const m = seq2.length;
        // 简单DTW矩阵
        const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
        dtw[0][0] = 0;

        for (let i = 1; i <= n; i++) {
            for (let j = 1; j <= m; j++) {
                const cost = vectorDistance(seq1[i-1], seq2[j-1]);
                dtw[i][j] = cost + Math.min(dtw[i-1][j], dtw[i][j-1], dtw[i-1][j-1]);
            }
        }
        return dtw[n][m] / (n + m);
    }

    function vectorDistance(v1, v2) {
        let sum = 0;
        // v1, v2 长度都是 30
        for(let i=0; i<v1.length; i++) sum += (v1[i] - v2[i]) ** 2;
        return Math.sqrt(sum);
    }

    // ============================================
    // 3. 录制与倒计时控制
    // ============================================

    const recordBtn = document.getElementById('record-btn');
    const countdownOverlay = document.getElementById('countdown-overlay');
    const countdownText = document.getElementById('countdown-text');
    let recordingTimer = null;

    window.toggleRecording = function() {
        if (isRecording) {
            finishRecording(); // 如果正在录，点击则停止
        } else {
            startCountdownSequence(); // 如果没录，点击开始倒数
        }
    };

    function startCountdownSequence() {
        const name = document.getElementById('gesture-name').value.trim();
        if(!name) { alert("请先输入动作名称"); return; }

        // 显示遮罩
        countdownOverlay.style.display = 'flex';
        let count = 3;
        countdownText.textContent = count;

        const timer = setInterval(() => {
            count--;
            if (count > 0) {
                countdownText.textContent = count;
            } else if (count === 0) {
                countdownText.textContent = "GO!";
            } else {
                clearInterval(timer);
                countdownOverlay.style.display = 'none';
                startCapture();
            }
        }, 1000);
    }

    function startCapture() {
        isRecording = true;
        recordedBuffer = [];
        recordBtn.textContent = "停止录制 (点击结束)";
        recordBtn.classList.add('recording');
        document.getElementById('status-text').textContent = "正在录制...";
        document.getElementById('status-text').style.color = "#ff4444";
    }

    function finishRecording() {
        isRecording = false;
        recordBtn.textContent = "开始录制 (倒计时)";
        recordBtn.classList.remove('recording');
        document.getElementById('status-text').textContent = "就绪";
        document.getElementById('status-text').style.color = "#00ffaa";

        if (recordedBuffer.length < 10) {
            alert("动作时间太短，请重试！");
            return;
        }

        const name = document.getElementById('gesture-name').value.trim();
        gestureDB.push({
            name: name,
            sequence: JSON.parse(JSON.stringify(recordedBuffer))
        });
        
        renderList();
        localStorage.setItem('dualHandGestures', JSON.stringify(gestureDB));
        
        showOutput(`录制完成: ${name}`);
    }

    // ============================================
    // 4. 实时识别循环
    // ============================================
    
    let lastRecognizeTime = 0;

    function recognize() {
        if(gestureDB.length === 0 || liveBuffer.length < 15) return;

        let bestScore = Infinity;
        let bestName = null;

        gestureDB.forEach(gesture => {
            // 截取与目标等长的实时片段
            const len = gesture.sequence.length;
            if(liveBuffer.length < len) return;
            
            const liveClip = liveBuffer.slice(liveBuffer.length - len);
            const score = computeDTW(liveClip, gesture.sequence);
            
            if(score < bestScore) {
                bestScore = score;
                bestName = gesture.name;
            }
        });

        // UI Feedback
        let visualScore = Math.max(0, 1 - bestScore/1.2) * 100;
        document.getElementById('score-val').textContent = bestScore.toFixed(3);
        document.getElementById('score-bar').style.width = `${visualScore}%`;

        // 阈值：值越小越相似。双手数据量大，误差会累积，阈值可以适当放宽到 0.6-0.8
        if (bestScore < 0.65) {
            showOutput(bestName);
            liveBuffer = []; // 触发后清空，防连击
        }
    }

    function showOutput(text) {
        const el = document.getElementById('main-output');
        el.textContent = text;
        el.classList.add('active');
        setTimeout(() => el.classList.remove('active'), 1500);
    }

    function renderList() {
        const list = document.getElementById('gesture-list');
        list.innerHTML = '';
        gestureDB.forEach((g, i) => {
            const div = document.createElement('div');
            div.className = 'gesture-item';
            div.innerHTML = `<span>${g.name} <span style="color:#666;font-size:10px">${g.sequence.length}帧</span></span> <span class="del-btn" onclick="delGesture(${i})">×</span>`;
            list.appendChild(div);
        });
    }

    window.delGesture = function(i) {
        gestureDB.splice(i, 1);
        renderList();
        localStorage.setItem('dualHandGestures', JSON.stringify(gestureDB));
    }
    
    window.exportData = function() {
        navigator.clipboard.writeText(JSON.stringify(gestureDB));
        alert("已复制到剪贴板！");
    }

    // ============================================
    // 5. MediaPipe & Render Loop
    // ============================================
    
    const videoElem = document.getElementById('input-video');
    const handCountElem = document.getElementById('hand-count');
    
    function onResults(results) {
        let leftLM = null;
        let rightLM = null;
        let count = 0;

        // 隐藏
        leftHandVisual.update(null);
        rightHandVisual.update(null);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            count = results.multiHandLandmarks.length;
            results.multiHandLandmarks.forEach((landmarks, index) => {
                const label = results.multiHandedness[index].label;
                // 注意：MP 前置摄像头镜像后，label Left 对应屏幕显示的 Right Hand Visual
                // 这里我们统一定义： label "Left" -> 存在 currentLeft, 渲染用 leftVisual
                // 但因为 mirror，视觉上我们可能需要交换一下，或者保持一致
                // 为了逻辑简单：Label Left 就归入 Left 数据槽
                
                if (label === 'Right') {
                    rightHandVisual.update(landmarks);
                    rightLM = landmarks;
                } else {
                    leftHandVisual.update(landmarks);
                    leftLM = landmarks;
                }
            });
        }
        handCountElem.textContent = count;

        // 特征提取 (包含两只手，缺少的补0)
        const feats = extractDualFeatures(leftLM, rightLM);

        if (isRecording) {
            recordedBuffer.push(feats);
        } else {
            liveBuffer.push(feats);
            if(liveBuffer.length > LIVE_BUFFER_SIZE) liveBuffer.shift();
            
            const now = Date.now();
            if(now - lastRecognizeTime > 200) { // 200ms 检测一次
                recognize();
                lastRecognizeTime = now;
            }
        }

        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2, // 开启双手
        modelComplexity: 1,
        minDetectionConfidence: 0.8, // 高置信度减少幽灵手
        minTrackingConfidence: 0.8
    });
    hands.onResults(onResults);

    new Camera(videoElem, {
        onFrame: async () => { await hands.send({image: videoElem}); },
        width: 1280, height: 720
    }).start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
