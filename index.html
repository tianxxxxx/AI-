<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>PC端手势交互 - 直接反馈版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: '微软雅黑', sans-serif; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #input-video { display: none; } /* 隐藏原始摄像头画面 */
        
        /* PC端 UI 侧边栏 */
        #ui-layer {
            position: absolute; top: 30px; left: 30px; width: 300px;
            background: rgba(30, 30, 30, 0.8); padding: 25px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        h2 { margin: 0 0 15px 0; font-size: 22px; color: #00d2ff; letter-spacing: 1px;}
        
        /* 输入框和按钮样式 */
        input { 
            width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #444; 
            border-radius: 8px; background: #2a2a2a; color: white; box-sizing: border-box; font-size: 14px;
            transition: border-color 0.3s;
        }
        input:focus { border-color: #00d2ff; outline: none; }
        button {
            width: 100%; padding: 12px; border: none; border-radius: 8px;
            background: linear-gradient(135deg, #00d2ff, #3a7bd5); color: white; 
            font-weight: bold; font-size: 16px; cursor: pointer; transition: transform 0.2s, opacity 0.2s;
        }
        button:hover { transform: translateY(-2px); opacity: 0.9; }
        button:active { transform: translateY(0); }
        
        /* 已存手势列表 */
        .list-container { margin-top: 20px; max-height: 200px; overflow-y: auto; }
        .list-container h4 { margin: 0 0 10px 0; font-size: 14px; color: #aaa; }
        #gesture-list { list-style: none; padding: 0; margin: 0; font-size: 13px; color: #ccc; }
        #gesture-list li { padding: 5px 0; border-bottom: 1px solid #333; }

        /* 核心功能：屏幕中央大文字显示 */
        #main-output {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px; /* 超大字体 */
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px rgba(0, 210, 255, 0.8), 0 0 60px rgba(0, 210, 255, 0.4);
            white-space: nowrap;
            pointer-events: none; /* 防止挡住鼠标交互 */
            z-index: 5;
            opacity: 0; /* 默认隐藏，识别到才显示 */
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        /* 显示状态的类 */
        #main-output.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.05);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="ui-layer">
        <h2>自定义手势定义</h2>
        <p style="font-size:13px; color:#aaa; margin-bottom: 15px;">1. 将手放在摄像头前摆好姿势。<br>2. 输入你想显示的文字。<br>3. 点击录制。</p>
        <input type="text" id="new-gesture-name" placeholder="输入要显示的文字 (例如: 暂停)">
        <button onclick="recordGesture()">⏺ 录制当前姿势</button>
        
        <div class="list-container">
            <h4>已定义手势库:</h4>
            <ul id="gesture-list">
                <li>预设: 张开手掌 (Open)</li>
                <li>预设: 握紧拳头 (Fist)</li>
            </ul>
        </div>
    </div>

    <div id="main-output">初始化中...</div>
</div>

<script>
    // --- Three.js 场景设置 (保持不变，用于可视化) ---
    const scene = new THREE.Scene();
    // 调整摄像机位置，适应电脑屏幕视角
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 22; 
    camera.position.y = 3;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // 电脑端开启高 DPI 支持，画面更清晰
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // 灯光
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const pointLight = new THREE.PointLight(0x00d2ff, 0.8);
    pointLight.position.set(15, 15, 15);
    scene.add(pointLight);

    // 手部模型初始化
    const jointMeshes = [];
    const boneLines = [];
    const handGroup = new THREE.Group();
    scene.add(handGroup);
    const jointMat = new THREE.MeshPhongMaterial({ color: 0x00ff88, shininess: 100 });
    const lineMat = new THREE.LineBasicMaterial({ color: 0x00d2ff, linewidth: 2, transparent: true, opacity: 0.6 });

    for (let i = 0; i < 21; i++) {
        // 电脑端稍微调小一点关节球体
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), jointMat);
        jointMeshes.push(mesh);
        handGroup.add(mesh);
    }
    const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
    connections.forEach(pair => {
        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]), lineMat);
        boneLines.push({ line, start: pair[0], end: pair[1] });
        handGroup.add(line);
    });

    // --- 核心业务逻辑 ---

    let knownGestures = []; // 存储自定义手势
    let currentLandmarksData = null; // 暂存当前帧数据用于录制
    let detectionTimeout = null; // 用于平滑显示效果的计时器

    const mainOutput = document.getElementById('main-output');
    const gestureListUI = document.getElementById('gesture-list');

    // 计算两个手势形状差异的函数 (欧几里得距离)
    function calculateDistance(l1, l2) {
        let total = 0;
        for (let i = 0; i < 21; i++) {
            total += Math.sqrt(Math.pow(l1[i].x - l2[i].x, 2) + Math.pow(l1[i].y - l2[i].y, 2) + Math.pow(l1[i].z - l2[i].z, 2));
        }
        return total;
    }

    // 归一化：消除手在屏幕位置的影响，只关注形状
    function normalizeLandmarks(landmarks) {
        const wrist = landmarks[0];
        return landmarks.map(p => ({ x: p.x - wrist.x, y: p.y - wrist.y, z: p.z - wrist.z }));
    }

    // 录制功能
    window.recordGesture = function() {
        const nameInput = document.getElementById('new-gesture-name');
        const name = nameInput.value.trim();
        if (!name) { alert("请输入要显示的文字！"); return; }
        if (!currentLandmarksData) { alert("未检测到手，请将手放入画面中。"); return; }

        // 保存归一化后的数据和名称
        knownGestures.push({ name: name, data: normalizeLandmarks(currentLandmarksData) });
        
        // 更新侧边栏列表
        const li = document.createElement('li');
        li.textContent = `自定义: ${name}`;
        gestureListUI.appendChild(li);
        nameInput.value = '';
        
        // 给个视觉反馈
        mainOutput.textContent = `已录制: ${name}`;
        mainOutput.classList.add('active');
        setTimeout(() => mainOutput.classList.remove('active'), 1000);
    };


    // MediaPipe 处理回调（每一帧都会执行）
    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            handGroup.visible = false;
            currentLandmarksData = null;
            // 如果手消失了，延迟一下再隐藏文字，避免闪烁
            if (!detectionTimeout) {
                detectionTimeout = setTimeout(() => {
                    mainOutput.classList.remove('active');
                }, 500);
            }
            renderer.render(scene, camera);
            return;
        }

        // 如果检测到手，清除隐藏计时器
        if (detectionTimeout) { clearTimeout(detectionTimeout); detectionTimeout = null; }
        
        handGroup.visible = true;
        const landmarks = results.multiHandLandmarks[0];
        currentLandmarksData = landmarks; // 保存原始数据

        // 1. 更新 3D 模型 (映射 MediaPipe 坐标到 Three.js 世界坐标)
        const worldPoints = [];
        landmarks.forEach((lm, index) => {
            // 电脑端映射参数调优
            const x = (1 - lm.x) * 30 - 15; // 更宽的X范围
            const y = (1 - lm.y) * 24 - 12; // 更高的Y范围
            const z = lm.z * -30;           // 深度
            jointMeshes[index].position.set(x, y, z);
            worldPoints.push(new THREE.Vector3(x,y,z));
        });
        boneLines.forEach(b => {
            const p1 = worldPoints[b.start], p2 = worldPoints[b.end];
            const pos = b.line.geometry.attributes.position.array;
            pos[0]=p1.x;pos[1]=p1.y;pos[2]=p1.z; pos[3]=p2.x;pos[4]=p2.y;pos[5]=p2.z;
            b.line.geometry.attributes.position.needsUpdate = true;
        });

        // 2. 手势匹配核心逻辑
        const normalizedCurrent = normalizeLandmarks(landmarks);
        let bestMatchName = null;
        let minDistance = Infinity;

        // 遍历已录制的手势进行对比
        knownGestures.forEach(g => {
            const dist = calculateDistance(normalizedCurrent, g.data);
            // 阈值设定：电脑端可以设置得稍微严格一些 (例如 0.55) 以提高区分度
            if (dist < 0.55 && dist < minDistance) { 
                minDistance = dist;
                bestMatchName = g.name;
            }
        });

        // (可选) 保留默认的基础手势作为演示
        if (!bestMatchName && knownGestures.length === 0) {
             const tips = [8,12,16,20];
             const opens = tips.filter(t => landmarks[t].y < landmarks[t-2].y).length;
             if (opens >= 4) bestMatchName = "Open Hand";
             else if (opens === 0) bestMatchName = "Closed Fist";
        }

        // 3. 屏幕文字反馈更新
        if (bestMatchName) {
            mainOutput.textContent = bestMatchName;
            mainOutput.classList.add('active'); // 显示文字
        } else {
            mainOutput.classList.remove('active'); // 没有匹配时隐藏文字
        }
        
        renderer.render(scene, camera);
    }

    // --- MediaPipe 初始化配置 (电脑端优化) ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1, // 电脑端使用完整模型 (0是lite, 1是full)，精度更高
        minDetectionConfidence: 0.6, // 提高置信度阈值，减少误识别
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const videoElement = document.getElementById('input-video');
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        // 电脑端使用高清分辨率
        width: 1280,
        height: 720
    });
    cameraUtils.start();

    // 窗口大小调整适配
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>