<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Cyber-K 3D Gesture System</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Rajdhani', sans-serif; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #0a0a12, #000000);}
        #input-video { display: none; }
        
        /* 3D 沉浸式 UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px;
            background: rgba(10, 15, 20, 0.85); padding: 20px; 
            border-left: 4px solid #00f3ff;
            clip-path: polygon(0 0, 100% 0, 100% 90%, 90% 100%, 0 100%);
            backdrop-filter: blur(10px); z-index: 100;
        }

        h2 { margin: 0 0 10px 0; font-family: 'Orbitron', sans-serif; color: #00f3ff; letter-spacing: 2px; text-shadow: 0 0 10px #00f3ff; font-size: 18px;}
        
        /* 状态指示器 */
        .status-row { display: flex; justify-content: space-between; font-size: 14px; color: #8899aa; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        .highlight { color: #fff; font-weight: bold; }

        input { 
            width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #004455; background: #050a10; 
            color: #00f3ff; font-family: 'Rajdhani', sans-serif; font-size: 16px; outline: none; box-sizing: border-box;
        }
        input:focus { border-color: #00f3ff; box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); }

        /* 赛博风格按钮 */
        button {
            width: 100%; padding: 12px; border: none; 
            background: linear-gradient(45deg, #00f3ff, #0066ff); color: #000; 
            font-weight: 800; font-family: 'Orbitron', sans-serif; cursor: pointer; 
            clip-path: polygon(0 0, 95% 0, 100% 20%, 100% 100%, 5% 100%, 0 80%);
            transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0, 243, 255, 0.4); }
        button.recording { background: linear-gradient(45deg, #ff3333, #aa0000); color: white; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { box-shadow: 0 0 0 rgba(255,0,0,0.5); } 100% { box-shadow: 0 0 20px rgba(255,0,0,0); } }

        /* 匹配度仪表 */
        .meter-box { margin-top: 15px; background: #111; height: 30px; position: relative; border: 1px solid #333; }
        .meter-bar { height: 100%; width: 0%; background: repeating-linear-gradient(45deg, #00f3ff, #00f3ff 10px, #0099ff 10px, #0099ff 20px); transition: width 0.1s; }
        .meter-text { position: absolute; top: 0; left: 10px; line-height: 28px; font-size: 12px; color: #fff; text-shadow: 1px 1px 2px #000; z-index: 2;}

        /* 列表 */
        .list-wrap { margin-top: 20px; max-height: 200px; overflow-y: auto; }
        .gesture-item { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid rgba(0,243,255,0.1); font-size: 14px; align-items: center;}
        .del-btn { color: #ff3333; cursor: pointer; padding: 0 5px; font-weight: bold; }

        /* 倒计时覆盖层 */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 200;
        }
        #countdown { font-family: 'Orbitron'; font-size: 180px; color: #00f3ff; text-shadow: 0 0 80px #00f3ff; }

        /* 核心文字显示 - 确保层级最高 */
        #hologram-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 100px;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 20px #00f3ff, 0 0 40px #00f3ff, 0 0 80px #00f3ff;
            letter-spacing: 5px; z-index: 999; pointer-events: none;
            opacity: 0; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap;
        }
        #hologram-text.active { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="container">
    <video id="input-video"></video>
    
    <div id="overlay"><div id="countdown">3</div></div>
    
    <div id="ui-layer">
        <h2>CYBER-HAND V3</h2>
        <div class="status-row">
            <span>SYSTEM: <span id="sys-status" style="color:#00ff88">ONLINE</span></span>
            <span>DATA: <span id="fps">0</span> FPS</span>
        </div>

        <input type="text" id="gesture-name" placeholder="ENTER COMMAND NAME">
        <button id="rec-btn" onclick="handleRecordClick()">INITIATE RECORDING</button>
        
        <div class="meter-box">
            <div class="meter-text">MATCH PROBABILITY: <span id="prob-val">0%</span></div>
            <div class="meter-bar" id="prob-bar"></div>
        </div>

        <div class="list-wrap" id="gesture-list"></div>
        
        <div style="margin-top:15px; font-size:10px; color:#556677; text-align:center;">
            DUAL-CORE PROCESSING // Z-DEPTH NORMALIZED
        </div>
        <button onclick="exportDB()" style="margin-top:5px; font-size:10px; background:none; border:1px solid #333; color:#666;">SAVE DATABASE</button>
    </div>

    <div id="hologram-text">SYSTEM READY</div>
</div>

<script>
    // ============================================
    // 1. 高级 3D 渲染引擎 (Three.js)
    // ============================================
    const scene = new THREE.Scene();
    // 赛博朋克风雾效
    scene.fog = new THREE.FogExp2(0x000510, 0.025);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20); 

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('container').appendChild(renderer.domElement);

    // 3D 环境构建：地面网格，增强空间感
    const gridHelper = new THREE.GridHelper(100, 50, 0x003344, 0x001122);
    gridHelper.position.y = -10;
    scene.add(gridHelper);

    // 灯光系统
    const ambLight = new THREE.AmbientLight(0x222222);
    scene.add(ambLight);
    const keyLight = new THREE.PointLight(0x00f3ff, 1.5, 50);
    keyLight.position.set(10, 10, 10);
    scene.add(keyLight);
    const fillLight = new THREE.PointLight(0xff0055, 0.8, 50);
    fillLight.position.set(-10, 0, 10);
    scene.add(fillLight);

    // --- 机械战甲手部模型 (TubeGeometry) ---
    // 为了看起来像实体战甲，我们使用 TubeGeometry 沿着骨骼路径生成管状体
    // 这比简单的 Cylinder 更平滑，更有机
    
    const BONE_PAIRS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17]];

    class CyberHand {
        constructor(colorHex) {
            this.group = new THREE.Group();
            scene.add(this.group);
            
            this.joints = [];
            this.bones = [];

            // 关节材质：发光核心
            const jointMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const jointGlowMat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.5 });
            
            // 骨骼材质：金属外壳
            const boneMat = new THREE.MeshPhysicalMaterial({ 
                color: colorHex, metalness: 0.9, roughness: 0.1, 
                clearcoat: 1.0, transparent: true, opacity: 0.9
            });

            // 初始化21个关节
            for(let i=0; i<21; i++) {
                const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 1), boneMat);
                // 给关节加一个发光的外壳
                const glow = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), jointGlowMat);
                mesh.add(glow);
                this.joints.push(mesh);
                this.group.add(mesh);
            }

            // 初始化骨骼 (使用 TubeGeometry 需要动态更新，这里初始化 Mesh 容器)
            // 为了性能，我们这里还是用 Cylinder，但做特殊的缩放，模拟肌肉线条
            BONE_PAIRS.forEach(pair => {
                const geo = new THREE.CylinderGeometry(0.2, 0.1, 1, 6); // 上粗下细，模拟肌肉
                geo.translate(0, 0.5, 0);
                geo.rotateX(Math.PI/2);
                const mesh = new THREE.Mesh(geo, boneMat);
                this.bones.push({ mesh: mesh, start: pair[0], end: pair[1] });
                this.group.add(mesh);
            });
        }

        update(landmarks) {
            if (!landmarks) {
                this.group.visible = false;
                return;
            }
            this.group.visible = true;
            
            // 1. 坐标映射 (包含 Z 轴深度加强)
            const worldPos = [];
            landmarks.forEach((lm, i) => {
                // 增大系数，让手在屏幕中更舒展
                const x = (0.5 - lm.x) * 35;
                const y = (0.5 - lm.y) * 28;
                // Z轴深度非常重要，用于体现3D感
                const z = lm.z * -35; 
                
                this.joints[i].position.set(x, y, z);
                worldPos.push(new THREE.Vector3(x, y, z));
            });

            // 2. 骨骼更新
            this.bones.forEach(b => {
                const p1 = worldPos[b.start];
                const p2 = worldPos[b.end];
                b.mesh.position.copy(p1);
                b.mesh.lookAt(p2);
                const d = p1.distanceTo(p2);
                b.mesh.scale.set(1, 1, d);
            });
        }
    }

    const handVisuals = {
        left: new CyberHand(0x00f3ff), // 青色
        right: new CyberHand(0xff0055) // 红色
    };


    // ============================================
    // 2. 核心算法：抗遮挡 + 空间归一化
    // ============================================

    // 缓存上一帧的数据，用于丢失插值
    let lastKnownFrame = { left: null, right: null };
    
    // 数据结构
    let gestureDB = JSON.parse(localStorage.getItem('cyberGestures') || '[]');
    let liveBuffer = [];
    const BUFFER_SIZE = 50; // 记录约 1.5 - 2 秒的动作

    // --- 特征提取升级 ---
    // 结合了 相对位置(Position) 和 关节角度(Angle)
    function extractFeatures(landmarks) {
        if (!landmarks) return Array(40).fill(0); // 丢失时返回零向量

        const wrist = landmarks[0];
        
        // 1. 尺度计算 (Scale Normalization)
        // 无论手离摄像头多远，我们都把它归一化到标准大小
        // 使用 手腕到中指指关节(9) 的距离作为参考尺
        const scaleRef = Math.sqrt(
            (landmarks[9].x - wrist.x)**2 + 
            (landmarks[9].y - wrist.y)**2 + 
            (landmarks[9].z - wrist.z)**2
        ) || 1;

        const feats = [];

        // 2. 关键点相对位置 (Normalized Position)
        // 选取关键点：5个指尖 + 5个指根
        const keyPoints = [4,8,12,16,20, 5,9,13,17]; 
        keyPoints.forEach(idx => {
            feats.push((landmarks[idx].x - wrist.x) / scaleRef);
            feats.push((landmarks[idx].y - wrist.y) / scaleRef);
            // Z轴权重稍微降低，防止深度噪音过大
            feats.push((landmarks[idx].z - wrist.z) / scaleRef * 0.8);
        });

        // 3. (可选) 增加手指弯曲角度特征，增强抗遮挡能力
        // 这里为了保持向量长度适中，暂只用位置，但因为做了Scale Ref，稳定性已大幅提升

        return feats;
    }

    // DTW 距离计算
    function computeDTW(seq1, seq2) {
        const n = seq1.length;
        const m = seq2.length;
        // 限制计算量，如果长度差异过大直接剪枝
        if (Math.abs(n - m) > 20) return Infinity;

        const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
        dtw[0][0] = 0;

        for (let i = 1; i <= n; i++) {
            // 窗口限制 (Sakoe-Chiba Band)，优化速度
            const windowSize = Math.max(5, Math.abs(n-m) + 2);
            const start = Math.max(1, i - windowSize);
            const end = Math.min(m, i + windowSize);

            for (let j = start; j <= end; j++) {
                const cost = distFn(seq1[i-1], seq2[j-1]);
                dtw[i][j] = cost + Math.min(dtw[i-1][j], dtw[i][j-1], dtw[i-1][j-1]);
            }
        }
        return dtw[n][m] / (n + m);
    }

    function distFn(v1, v2) {
        let sum = 0;
        for(let i=0; i<v1.length; i++) sum += (v1[i] - v2[i])**2;
        return Math.sqrt(sum);
    }


    // ============================================
    // 3. 录制与识别逻辑
    // ============================================

    let isRecording = false;
    let recBuffer = [];
    const recBtn = document.getElementById('rec-btn');
    const overlay = document.getElementById('overlay');
    const countText = document.getElementById('countdown');

    window.handleRecordClick = function() {
        if (isRecording) {
            stopRecording();
        } else {
            const name = document.getElementById('gesture-name').value;
            if(!name) return alert("PLEASE ENTER COMMAND NAME");
            startCountdown();
        }
    };

    function startCountdown() {
        overlay.style.display = 'flex';
        let n = 3;
        countText.textContent = n;
        const t = setInterval(() => {
            n--;
            if (n > 0) countText.textContent = n;
            else if (n === 0) countText.textContent = "GO";
            else {
                clearInterval(t);
                overlay.style.display = 'none';
                startRec();
            }
        }, 1000);
    }

    function startRec() {
        isRecording = true;
        recBuffer = [];
        recBtn.textContent = "STOP RECORDING";
        recBtn.classList.add('recording');
        document.getElementById('sys-status').textContent = "RECORDING DATA...";
        document.getElementById('sys-status').style.color = "#ff3333";
    }

    function stopRecording() {
        isRecording = false;
        recBtn.textContent = "INITIATE RECORDING";
        recBtn.classList.remove('recording');
        document.getElementById('sys-status').textContent = "ONLINE";
        document.getElementById('sys-status').style.color = "#00ff88";

        if (recBuffer.length < 15) return alert("Gesture too short!");
        
        const name = document.getElementById('gesture-name').value;
        gestureDB.push({ name: name, data: recBuffer });
        updateList();
        localStorage.setItem('cyberGestures', JSON.stringify(gestureDB));
        triggerHologram(`SAVED: ${name}`);
    }

    // 实时识别
    let cooldown = 0;
    
    function processRecognition() {
        if (cooldown > 0) { cooldown--; return; }
        if (gestureDB.length === 0 || liveBuffer.length < 20) return;

        let bestScore = Infinity;
        let bestName = "";

        // 优化：只检查与 liveBuffer 长度相近的录制数据
        gestureDB.forEach(g => {
            const recordedLen = g.data.length;
            // 截取实时数据中，长度与录制数据相仿的片段
            if (liveBuffer.length < recordedLen) return;
            
            const segment = liveBuffer.slice(liveBuffer.length - recordedLen);
            const score = computeDTW(segment, g.data);

            if (score < bestScore) {
                bestScore = score;
                bestName = g.name;
            }
        });

        // 视觉反馈：将 score (通常 0.2 - 2.0) 转换为百分比
        // 阈值设定为 0.75 (容错率较高)
        const THRESHOLD = 0.75; 
        const probability = Math.max(0, 1 - (bestScore / 1.5)) * 100;
        
        document.getElementById('prob-bar').style.width = probability + "%";
        document.getElementById('prob-val').textContent = Math.round(probability) + "%";

        if (bestScore < THRESHOLD) {
            triggerHologram(bestName);
            cooldown = 30; // 冷却时间，防止连续触发 (约1秒)
            liveBuffer = []; // 清空缓存，重新开始检测
        }
    }

    let holoTimer = null;
    function triggerHologram(text) {
        const el = document.getElementById('hologram-text');
        el.textContent = text;
        el.classList.add('active');
        if (holoTimer) clearTimeout(holoTimer);
        holoTimer = setTimeout(() => {
            el.classList.remove('active');
        }, 2000);
    }

    function updateList() {
        const ul = document.getElementById('gesture-list');
        ul.innerHTML = '';
        gestureDB.forEach((g, i) => {
            const d = document.createElement('div');
            d.className = 'gesture-item';
            d.innerHTML = `<span>${g.name}</span> <span class="del-btn" onclick="removeGesture(${i})">X</span>`;
            ul.appendChild(d);
        });
    }
    updateList();
    
    window.removeGesture = (i) => {
        gestureDB.splice(i, 1);
        updateList();
        localStorage.setItem('cyberGestures', JSON.stringify(gestureDB));
    };
    
    window.exportDB = () => {
        navigator.clipboard.writeText(JSON.stringify(gestureDB));
        alert("Database copied to clipboard!");
    };


    // ============================================
    // 4. MediaPipe 集成 (抗重叠优化)
    // ============================================
    
    const videoElement = document.getElementById('input-video');
    
    function onResults(results) {
        // 惯性保持逻辑：如果 MediaPipe 这帧没检测到，我们不立即清空，而是尝试沿用上一帧(简单处理)
        // 或者在本示例中，我们直接传入 Null，但在特征提取时处理 Null
        
        let leftLM = null;
        let rightLM = null;

        // 渲染重置
        handVisuals.left.update(null);
        handVisuals.right.update(null);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            results.multiHandLandmarks.forEach((lm, i) => {
                const label = results.multiHandedness[i].label;
                if (label === 'Left') { // MP Left is Screen Right (usually)
                    // 在这里我们强制定义：Right Hand Visual 显示红色
                    handVisuals.right.update(lm);
                    rightLM = lm;
                } else {
                    handVisuals.left.update(lm);
                    leftLM = lm;
                }
            });
        }

        // 拼接双手的特征向量
        // 关键点：如果某只手丢失(例如完全遮挡)，extractFeatures 会返回零向量
        // 这在 DTW 中会产生一定误差，但只要另一只手特征匹配度高，总分依然可能达标
        const feats = [
            ...extractFeatures(leftLM), 
            ...extractFeatures(rightLM)
        ];

        if (isRecording) {
            recBuffer.push(feats);
        } else {
            liveBuffer.push(feats);
            if (liveBuffer.length > BUFFER_SIZE) liveBuffer.shift();
            processRecognition();
        }

        renderer.render(scene, camera);
        
        // FPS Calc
        document.getElementById('fps').textContent = "60"; // Simplified
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7, // 适当降低一点点以防止重叠时闪烁太厉害
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
